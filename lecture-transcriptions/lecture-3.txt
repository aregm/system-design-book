 Do a little bit differently than we're doing. We did the 1st 2 lectures and we're going to use some kind of. Dialogue between me and my colleague Peter. So you guys will see. All to engage and what is important, what questions are important. So I will start, then I will pass it to Peter. And we will start discussion. So please. Feel free to chime in. Ask questions. We can have. Live lecture. Today's topic is decompositions on the 1st 2 lectures. We discussed requirements how the system is actually emerging in terms of the customer requirements, what the life cycle is, how we should capture requirements, their role in decomposition and system design in general. Then the lecture 2. We discussed the first level of decomposition, how we are going from the requirements. Twitter conceptual design. What is the integrity of the conceptual design? Consistency and we discussed, you know, details the role of a concert and what the concept is and what's the role of the concert and the part of the conceptual design. Now we are going to the central theme of the course. The next two lecture. These lectures on the second one and the one after. We'll see how it goes. Are about how we do low level system decomposition and how we are going to create obstructions out of it. So system decomposition. Is. Central and the most controversial thing in system design. I think that the most important questions are never being asked and answered explicitly. There are many definitions and in for. Our to look to the finishes out there for. Our course. The most important central question is how we transit from the concert. The idea of concert to idea of a subsystem module. If you look. To textbooks. Dictionaries et cetera. So you'll see a definition like this, but the system decomposition begins with the composing the system into cohesive well defined subsystems or components and. All the definitions are flavours of this definition. Somebody use. Some terms of objects, modules, procedures, algorithms cohere the but the word cohesion. Structures well defined are all there. So. Why are we doing this? Why? First of all, what is causing this? Have you guys heard the word cohesive? Something understandable. OK. Any other definitions? Any other? Hmm. The same is understandable. I think you are mixing it with the word comprehensive. Oh yes. Your your ideas? Just tell us. So cohesiveness is about how the parts are forming the whole and how well they are working together to form the whole. Maybe it's a little bit. Abstract definition. But how part of parts fit together to define the whole? So. For example, can you give me an example of the Coe easy parts versus non cohesive parts? And we have the first lecture we saw the. The composition of a car, right? For example, if you put. Skis instead of. Deals is not very cohesive. Or if you put. Voice take instead of wheel is not very cohesive though with the company's special U.S. companies. Who are you not using driving wheel as a circle without using something called yoke? Anyway, this is about the coasiveness. What about? Well defined? What does it mean? Well defined. This you should know because we talked about this first products quite extensively. Remember guys. And Peter, I will seek your help here. I'll start. For example. It is complete. Unsound. OK. I think in terms of the decomposition, I agree with you. If we like unpack the complete and sound, I think the most important thing is that it has very clearly defined obstructions for inputting and exiting those subsystem. So interfaces are clear, it is absolutely. As you say, complete in what it does, it is not. Doing something in the background. So that's how we in the first tuition in the first. Oh sorry, forgot to work. Conjunction. The first step of the conjunction we are defining. Well defined, but we will continue defining that and we will continue refining that definition. So. The system decomposition was a topic that was very popular and central for serious, very serious researchers and practitioners in this field and. It started in the 60s and so when computers start being ubiquitous in terms of their availability in the large computer centers. And the dominant thing at that time was top down, so. Breaking problem into hierarchical levels. When you have part of the system working together. But they are divided into smaller modules, but they can stitch together and enable the whole system to work. And this was the natural method because first of all there was no any precedence. And 2nd this is. This was the dominant view of the world as a top down hierarchical system. Very quickly. Well understood the the importance of this, what they call modular design and the concept that was brought by Corden, Jordan in their book and then Jordan and Constantine in their book, which is called, which was called Structured Design. Where you are seeking for independent units, this was also. Inspired by. Civil engineering with well defined interfaces, then stitched together, combined together, become. Larger system. I don't. Last time we talked about this one, this one influenced this movement of structural design and structural programming. Very, very profoundly with his motto or his approach, which was called divide and conquer as a strategy. How do you build larger system and well defined modules? And it was the dominant structured design structure. Decomposition was dominant. Until. Late 70s, beginning or 80s when. The rise of. What's the rise of the programming paradigm called object oriented? From. Languages such as small talk and similar. And that was fueled by the increasing compute capacity. Where now you can look into the program. As a side of interacting objects. Instead of doing top down modular decomposition. In parallel, there was a. Movement or still is the movement. She was a marched in inside. IBM called Tfd data flow diagrams where you focus on. Data flow and what in which points and when data is being changed and altered. And doing the functional components. Between those interactions between those changes. So modern approach approaches of the system design, influenced heavily by the. Rise of cloud computing, where now the focus is on microservices, micro services based architecture when you again. Breakdown the system into. Small, independently deployable modules and. This to my memory this is maybe the 5th of this idea before in the 90s there was. Methodology called CORBA component Object relation based. Something I don't remember. It was created inside of some Microsystems with the same idea that we now have a micro computers connected with the local area network. So let's design the system as a small services that are interacting through a very, very standardized protocol. This pan out because the perform with the problem with the tool chains. The probability was hard. The performance was not good. And it was very hard to do simple things. Same is true for micro services, by the way. Then there was series of different. Which is starting with the and it was very popular in Microsoft starting with. Object linking and embedding component object model, distributed component object model. Back to backs, et cetera, et cetera, et cetera. So many of them. But we today we are talking about. Of the decomposition and we are starting with the most. Old one, which was. Dominant in the 70s and here I will turn it to Peter. And I would like them. I would like him to take it from here. Well, I will start asking some dumb questions. Sounds great to me. Oh, wait, Arabic. Yes, go ahead Arabic. No, there is a question. I'm really sorry, but could you again briefly explain what is like? What is the position? What is the composition? Yes, the. Decomposition is a process of breaking down the conceptual high level design into smaller parts that are comprising the system, so you can program it, build it and deploy. Let's say the same example for the Git, right? If you go from, if you have a git and you have requirements, you cannot program that. You need to derive some concepts from the requirements which we discussed last time, right? Then you need to program the. Actually you need to. Go from the concepts to modules to subsystems and then you need to program. Those modules and subsystems so you can create a git. So we're now discussing explicitly. How do you decompose the high level conceptual design to smaller level lower level? Manageable parts. Is it clear Arabic now? Yes, yes. Thank you. OK. Peter, please go on. And I'll give a very, very down to Earth example for that here. So we will start with functional decomposition decomposition, which is a very natural thing for people to do. You can think about it as taking in the requirements for the system and transforming them one to one, basically 2 components. If your system is required to produce reports, you would create a reporting component. If your system is supposed to sort something, you would create a certain component. I actually yesterday I I looked up a a project from Microsoft Research. There is. A fancy approach for building AA solutions where you build agents, right? Each agent is based on an OLM and the agents are basically. Fulfilling some functional capabilities, so the whole thing is like a functional decomposition. But back to very simple example. So. Oh, you mean the the one with the when you write prompts on it to does something and generate code for you. Yeah, exactly. So an agent is just like an LLM with a prompt for example. There was literally a sorting agent. The prompt was you're now a data scientist that helps prepare the data in your task is to sort the data according to some rules. That was the prompt for the agent. I found that really funny. So instead of using. Long sweated algorithms by great minds of the 50s to 70s. They just use an LLM to sort stuff. But wait, isn't it? OK. What's wrong with that? Umm. We'll get to that. Oh, OK. With this small example, so I have a very down to Earth example of a house. So assume we are building a house until requirements. Is that you can do different things inside that house. You can do cooking, bathing. You can pay you both. You can eat there. Sometimes you need to clean and slip. If we then transform that to a set of components that each. Implement that quote UN quote functionality. So you would have a component that implements cooking. Now if you look at what happens, can you move to the next slide? Direct please. There are some problems with that approach. Since we naturally. Express requirements as modules. We will now have to change the modules when the requirements change. Requirements change all the time, right? So it is natural for our system to be susceptible to a lot of changes. Not only the changes are inevitable, the. Changes span across components. For example, if I'm changing cooking rights the like, let's say I've built my cooking functionality that allows me to heat up soups in a microwave, right? So now if I want a grill, I'll have to do some changes to the air. The other components, for example, I'll need to move my sofa to accommodate accommodate for. Grilling device. Which leads me into a component that was reading since now I have to change how the reading is implemented because now I have to move this over. Slide please. This also leads to explosion of components, right? So modern systems have. 1000 and thousands. Single functionalities, right? If you building an enterprise system, you have a lot of customers. The customers will have different requirements, so for each of those requirements you'll have to build some components. Since the requirements are different, you'll have to somehow accommodate the changes inside a component. If you have cooking, you'll have to have multiple versions of cooking for different customers. The functionality within those modules will also be duplicated across the modules, since for example, if you implementing 2 activities inside your house, such as eating and programming, you'll have to duplicate a table functionality. A table here like is like a high level concept that you had to embed into both of your modules because of the way you have decomposed the system. But isn't this like natural way of decomposition? That was that is predominant. Exactly. It is most. And what are the problems here? Sorry God. Most of the systems are built like that. And people suffer tremendously because of that. Most of the software. Projects go over budget. Over break deadlines because of the terrible design which just comes naturally from the functional decomposition. Do we have any good example of the functional decomposition which is bad and the good example of functional decomposition which is good? The bad example. Well, the bad example. Sorry big so this. This example with the House, I think the next slide shows how to build a house. No, the the IT has a domain. What? Whatever. Imagine you're building. A house in a functional way. So we have to build just the cooking. You would build a microwave, some walls around the microwave and the roof and the roof and plug it into electricity and blah blah. So then you would have to build another module which is for example entertainment. So you'll have to decompose back the. The thing that you've built and rebuild it again. So since you are rebuilding it. For the next piece of functionality and happens over and over over time, your time spent on accommodating a change is limiting your progress so. The you get diminishing returns from introducing new functionality to the system, and the time for meetings is increased once. The once you hit a certain thresholds, you will not be able to actually add any new functionality and this is where the system would literally die. On the contrary, for us to like a good example of functional decomposition. One thing that comes to mind is actually not a decomposition of a system, but rather a process. So I think functional decomposition is very useful when you're trying to figure out the actual requirements for a system. Since it unleashes the true. True. Requirements that are hiding behind solutions. Sometimes customers would throw requirements at you that in a form of a solution. For example, cooking is not actually a requirement. If you think about it. Cooking is a solution that provides nurturing for occupants of a house. If you if you. I would like to kind of pause here to see if there are any questions 'cause. I think we unpacked a lot and we didn't get into the actual programming part, but I think what we guys are what are we doing here is we are developing intuition about this. So any questions here? I see a question azmik. So I think no, I have a question about when we are designing a system. At first it's good to do some functional decomposition for understanding what we need. For the core functionality and then just use different paradigm for for our solution or it's not what you meant. That's exactly a good thing to do. All right. Can you jump? No, I think that this isn't. Two slides forward. One more slide, this one. Next one. The next one, yes, I think that what you. Saying that, if you remember that on the 1st lecture we discussed requirements, right? And we say that the requirement should be hierarchical in terms of. It is good to have like hierarchical requirements. We have had a requirement which you then break down to first level of more detailed requirement and this will be good. Or it's practical to go one level more, two level breakdown and that is exactly the right place where you can do functional decomposition of the requirements, which is recommend. Again there are many ways to do this. This is our view. We are not mandating that this is the only way to do it, but this is practical in our opinion. That's what Peter was trying to do and that's what we here have here, right? Yeah, exactly. This slide illustrates just that. So if you just take the requirements and then try to unpack them. They are usually our solutions. So if you strip the solution from from, the actual thing that you're trying to achieve, you get to a new requirement. And this process can be iterative until you hit something higher level at conceptual level. And then you might hit something that is stable enough to be expressable as a component. Or concept in the in this case like now you yes. Now at the end Exactly. you have. Function which you can creatively map to a form. OK. Is it clear rasmic? Yes, yes. Have you seen a problem by the by the way with that? I guess it's a question for me. Yes, no the 1st. I think that there's a problem because it's. It requires practice and. Fighting temptation to stop when you're unpacking requirements. Because usually what people do, they at most do one level on packing and then call the day and say OK, we're done. This is going to this. This is going to this function and we're done. It's very, very simple and kind of process oriented but will not get you good results. So that's for me, is the most. Dangerous thing. Do. What's yours? Question. Yes, I was gonna. Sorry, I have a question regarding to the composition of a system. So is there any tool or strategies to to be ensured that our decomposition is the best or to check it somehow before? Starting. That's a very good question and. The. Paralysis is no, but yes. So you are hitting a part which I can cover the end of the course. Like, how do you choose between some of the composition? Practical. What you're saying is that, hey, guys, you told us that you can do multiple ways, right? And at the end I can get to. The compositions. Which one should I choose? That's practical. Yeah. No question. We are hitting now or getting into the system engineering domain here because now what you can do is one of the ways to do it is you can rank them and you can rank them against requirements by assigning. Or satisfiability of the requirements. So there are ways to do it. One is called. And the second one is called non dominance and we can discuss this later, but. At the essence, it's still more an art than is science 'cause. If there will be very clear science or very clear scientific method to do this, we will have only perfect solutions, which we don't. What? So. Yes, there are some tools that you can use. Run. Most the have you guys. Studied optimization theory in the university. OK. So we will patch it then at the end of the course. The the essence of it, it's. Part of that optimization theory, which is called multi objective non dominant optimization. And it's it can be directly or indirectly apply here. Keep it for now. Remember that. No, it's more like. An intuition but can be. I want buy some toys, OK. Oh, OK. Yes, thank you. OK. Where where we are Peter. You were asking something. No, no, we we will actually touch on the way to produce a good decomposition today, right? So but first, yeah, let's finish with functional decomposition. So the last problematic bit with it just for the demonstration purpose why it is bad. So if we produce a functional decomposition. And back to the. Example with multiple customers. Let's say you have some here. I have parsing, processing and printing logic. Whatever that is, I didn't think about what it is exactly, but let's pretend that this is the some of the requirements we need to parse something. Then we need to somehow process the parse results and then we need to print the some kind of a report. We may have multiple customers that do want to see the things slightly differently, right? Some of them will have different requirements for processing the data. Some of them will have will need to see the report in different ways, and so on. So to a couple of date that those changes you need to you need some logic that would be guiding how these components that you've defined. Stitched together. So on the left there is an option where you create some kind of a client for your logic, right? So it is very easy to think about that in terms of microservices, right? This is exactly what happens often. When people built microservice architectures. You would have microservices for parsing, processing and printing, and then you would have some kind of a client which may also be a service. That knows what order and how exactly. To call these other microservices. This of course bloats the logic inside that service, and if you have any changes then you either have like a tree of decisions within that single orchestrator, or you have multiple of them, which is probably equally bad. Each of them will have additional logic to set the parameters for the each microservice to handle these their states. Then you would need to handle the errors that come of those services and also you would need to make sure that the. Flow itself, like for example, since there is a natural order in which those services need to be run. The the since the error can happen at any point in time, you'll need some mechanisms to roll back the changes that you've made. Those may be in some databases and so on. So this. Bloats the complexity in the orchestration logic. Another option that you have, you may say, well, I still want my functional decomposition. I would just reorganize it differently. I would just make services call other services or modules calling other modules. This is also bad, right? Because then you would move this bloated logic inside those services. Now you have a single. Then tree point as a client. But now each service knows about the internal implementation details of other modules. Again, they need to set the parameters they need to handle exceptions and they need to somehow recover from errors. And on the right side, I can give you a real example. In the beginning of 2000s, a very well known compiler, GCC ignore compiler collections. Needed to add Unicode support. And they did exactly the right picture. They said, OK, if it's parsing now if are we parsing ASCII or parsing UTF blah blah blah blah then are we tokenizing ASCII or are we tokenizing GTF and then etcetera so it creates this bloated function? And ressed it nightmare and it was very quickly redesigned and rebuilt. So this. Yeah. Yes, go ahead, mirror. Is it something that you're talking about, like single responsibility? To decouple or decompose do the decomposition. No. Of the functions that we have because it's like it has a lot of extra logic inside it and we need to decouple most of them from that function. Single responsibility principle is. Rarely single. And even rarely responsibility. It's part of this so-called solid. Which is derived from object orientation. We are not going there yet and if you guys want we can have a discussion about, for example, why personally I. Peter, maybe I think that solid is not good. I think you can see it even here, right? So here, for example, you've done so. I think they are a little bit orthogonal, so here you may argue that. With this functional decomposition, I have single responsibility of components, right? So my parsing component does only one thing it parses. The problem is that you cannot contain all the changes within this component, right? So it needs to talk to other parts of the system. Cannot get rid of that because there is no other place for it. You can put that logic into orchestrator on the on the left, right, but then you still have the same problem. It's just in the other dimension. Does that make sense? Yes, but if parsing close to for example processing, I guess it's the same thing because as a single responsibility, because parsing does what it does and then after that it calls to processing, right? In the right hands that we have in the picture. I'll just give you example for the GCC. What are so when you do parsing? Like, it's very hard to say. Hey, we are going only to do this one thing on this one object, right? For example, in the example of GCC, it was kind. We're going to parsing and if the symbols are known as Q are going to do this thing, et cetera, et cetera. In terms of this SRP single responsibility principles, you are still doing it. Single responsibility, right? You are parsing only, but the complexity inside the parsing is bloating because what if? I'm reading not from the file, but from the stream. What if it's not UTF 8 but UTF 16? What if I need to now add? I don't know Kui etcetera which is creating. Burden on me, maintenance right and. It is reducing the flexibility of your parsing function parsing object. And also the affecting the other parts because it's blurring the the what's called responsibility boundaries like where the parsing responsibility in terms of the change. Now it's a very important word change. And the responsibility of the other start. So single responsibility principle is good as a principle implementation of it is tricky if you don't do the right decomposition. Because usually there's a spectral as a single responsibility, you just say, oh, we are now going to create usually class with one function. That's the one spectrum. The other spectrum is that we are going to create a BLOB big. Metal object that does one function which is the whole system. What is the right level? That is the question we're trying to answer here. Did we also tell you your question here? Yep, Yep. OK. Yes, Rosen, go ahead. So how they changed the implementation of the parsing of that UTS? So what was the what was the right way of to do it? That's a good question. How would you do it? OK. That's a very good question and think about it and we will answer it at the end of the lecture or in the chat. But I think the answer will come naturally at the end of the lecture, OK. OK. Please call Peter. Right. No more questions here at the at this point it seems. Can we move to the domain decomposition now? With a this with a this with a this there is no question about this, right? So it's clear. So we're going to domain. Oh, actually, actually, there was one note about the previous slide here. So we mentioned stopping, not the requirements of solutions. We mentioned the problem with. Stopping too early when you've unpacked. A requirement and you discovered a new one, but that's not a good concept to abstract. There is also. The opposite problem that exists if you try to unpack everything, like literally everything and see and and try to abstract and abstract and abstract, then you reach a point where abstracting the you you are trying to abstract the domain of your. System as in what? What problem are you trying to solve? Like if it's a compiler I'm trying to obstruct the compiler itself. Which is not a good idea of course, because your system exists within the, let's say organization or some some structure that solves an actual real world problem. And it has to adhere to the requirements of that particular. Knowledge area or problem area so it has to be somehow specific. The system cannot be completely abstract. OK. Now we can go to domain. The remainder position. So let's we we've looked at functional decomposition and we see that there are problems with it, right? So let's try to do better. A natural way to do better is to say, well, if functions do not work, let's try to do to go bigger. Right, let's try to unify the functionality in domains. Going back to our house example, let's build a kitchen. Right, let's build the bedrooms, the attic and so on. It turns out that the main decomposition is just functional decomposition in disguise, so the IT produces designs that are sometimes even worse than those with functional decomposition. You have literally the same problems. If you go to the next slide. We had a functionality that is sleeping right and here again you have. Module duplication. If you have two bedrooms, you'll have to implement sleeping twice. Yes, they'll have the. The bedrooms are unique, but you still have to support the same set of. Functionality and fulfill the same set of requirements. So of course module duplication requires higher support efforts and it bloats the complexity. The ultimate example of well. Let's say the ultimate. Principle that you're breaking is very much evident when you're trying to build the system in such a way. So I have a very nice house. In the next slide. Let's try to build our house using the domain decomposition, right? So I started the I start with the kitchen, right? So I'm trying to reach the first milestone. They ship the first portion of the system. And identified that kitchen is the most valuable piece for my customer. What I do is I build the kitchen from ground up. I do the foundation. I build the walls. I build the roof. I connect the kitchen to power supply to water supply. Turn the the wiring. Put in some tables and microwaves and here we are. I have the cooking functionality built, milestone one completed and I'm shipping the code to the customer. No. For milestone two, I want to build a living room. So far it's been great. We we've done great development. Everything was fast and clean. And now we've got a little bit of a problem here. So we to build a living room if we want the solution to be efficient and not build the living room as room as a separate building. I start with some. Necessary steps which are demolishing the outer walls of the kitchen unbolting it from the foundation and blah blah blah. Only when I'm done with all the steps can I now start building my new solution. So I'll build the outer walls again for the kitchen and living room. I'll connect everything again. And I'll build out the functionality. Now I can ship the milestone 2.0, but you see this is insane. If you ever see somebody building a house like that. You would probably think they are insane and you would definitely not want your house built that way. So question is why do we think that is a good idea for software? I'm going back to the GCC as a compiler. I think that this is a good example where. I hope you will agree with me that. The compilers were built for. In a very monolithic domain driven thing and nobody ever thought how I'm going to, am I going to write down in terms of retarget ability? Front ends, adding more optimizations, etc. Until LLVM, which decompose the. Compiler from the monolithic into very well managed. System components and on the first of all, it separates the front and from the back end inside the front. The front end is driven by AST and the back end is driven by. Llvm IR, which is representation of the SSA and then suddenly everything became very clear. Do you agree, Peter? I agree, but I don't think you can just throw terms like SSA without mentioning what that is. Yes, sorry, that's bad for me. So anyway we can. We're going to discuss the hope we're going to discuss the compilers and their. The composition is one of the examples and we will go through this. I think in the 8th lecture. Any questions so far? I know that in enterprise programming or general programming, the domain decomposition and also there is a movement called. Tdd, right? Domain driven decomposition. Domain driven design. Is very popular, but here Peter very concisely explained. That it has advantages and disadvantages. And the same you this is. This is reminding me that there's one more. Popular approach is called pass driven design. Right. Tdd. Pdb. Yeah, I know whether you guys heard about that. Hmm. But it says that hey, you need to write tests 1st and then practical tests are being the acceptance criteria for the requirements and you build the system to pass the pass the acceptance criteria. And for me, it's a very dangerous idea. Because you are not going into the decomposition, you are practically hacking system to pass the tests. But that's my opinion. What do you guys? What do Peter think about? Well, I actually used TDD in practice. But that has to be done together with proper decomposition. So once once you have the right abstraction and you want to Brilliant. Competitive. implement that, then you can do TDD because it you have clear requirements for your component and you can just program them as tests beforehand and then your. Implementation is easier. And hacking is actually good sometimes. So if you hack your way through. Skipping some implementation of. Complex but maybe unnecessary implementation. You cut the corner, you get to the result quicker and maybe that complex. Implementation will actually never be needed. Yeah, that's good point. I think what we're trying to emphasize here that all these facetings are more or less tools. They are not going to substitute the fundamental process of the composition. If you try to substitute then you have a problem. But if you do it in a proper way, then for specific application you can use the tool which. Can be DDDTD or object oriented or whatever. So there's no problem with that, but using only one tool to nail everything. That's the problem that we are trying to avoid here. Yeah, this is about object orientation decomposition. One of the things that is very popular nowadays. Yes, you have a question. Go ahead. So what were the disadvantages of domain decomposition? OK. OK. What do you think? Advantages. Oops. That, like we clearly see the disadvantages for in this example like we should implement. A function. More than once in different domains, if it's needed. But what about the advantages? I don't know. So advantages are very kind of simple in terms of that domain, which is business language creates a context and the good thing is that it creates notions and concept not concepts but context of the operation which are very bounded and embedded into the business domain like here is. A kitchen bathroom, one bedroom, 2 completely bounded context and. Each bounded context. And as represent. Specific part of the main you are working with. These isolation help you to do reasonable yes good. So it does some structure. Sorry, it does some sort of classification of functions or I don't know like. Or separates it. Again, can you please rephrase it? So can we say that domain? The composition the advantage of domain decomposition is the fact Hmm. that it separates. Or or. Let's say classifieds the function. No, no. The advantage of the domain driven decomposition or domain decomposition is that at least derived from the business logic. So it has. It is creating first of all ubiquitous language to reason about. But what is important for business? It is creating the context of the notions and concepts that are important for business and this context are bounded. In this case it was like hey. We need kitchen or in bedroom. One garage and this other. Domain elements and all domain contacts that are important for the customer and for the business and also it creates what is called domain model. We are in this particular domain and here is building house for single single family house and these are the elements that are important and. These elements constitute the bounded context and we are operating in those bounded context so. A language is context boundaries. Those are the advantages, laughingly. OK. Thank you. Welcome. OK. Next. So I was gonna. Check. OK. OK, object orientation, object oriented design and object oriented decomposition. So. Peter touched the functional and domain driven. The other one is object oriented decomposition. And. It's very popular, right, you guys. Most likely learn this in. One of one or two or more courses. In the curriculum of the university it is. Deeply embedded into the programming languages nowadays, most of programming languages have to. One way or another, object orientation. And object oriented decomposition is that hey, we are defining the requirements, then we practically do a vocabulary based. Key object determination. Wait one of the. Well known methods that was popular. Back 90S is to create a vocabulary of the system and then. Separate nouns from verbs and nouns will become objects, and words will become messages between object. And then you look to the nouns and then you. Encapsulate them in terms of the sign in responsibility and. Here what single responsibility principles come cleaned or it will be good so class to have one? One more single responsibility you create. Inheritance. Class hierarchies. And you do the aggregation, composition and association and the system. Will work as a message passing. Using message passing interference because calling method is a message pass. This is the dominant method nowadays. Which I would think it is problems. There's lots of problems. If done incorrectly and not in the right place. Complexity is a big thing. Designing a large system, you know purely object oriented way is going to be a nightmare. You will end up with a very deep inheritance hierarchies because you wanted to apply object oriented orientation. And system roles. We managing the hierarchy becomes very, very challenging. Performance overhead is less of an issue, but still can be an issue, especially if you want to do a simple functionality, but you need to instantiate a huge hierarchy. The another problem which I think is. One of my favorite problems is that not all problems are naturally object oriented. For example. Rap. Graph is not naturally object oriented. You don't map it to the object oriented program. One of the good examples that we I have is maybe we should even program that. You guys know what Terminal Linux terminal is? Yes. And you know that. The standard you know external is 80 by 25, right? It's 80 symbols. Y-25 symbols 25 lines in the vertical. So that's the standard Unix terminal size. The question will be, let's say you have a different display and you need to convert 80 to 25. So you have input 1. Terminal and one terminal. You are inputting 80 to 25 one terminal which is 80 to 25. You are typing commands and you have another terminal which is doing different display because 132 by 45. And you need to show it there. Think about this problem in your spare time. It's not an obvious problem. How do you convert from one format to another? 'Cause here you are going to have a lot of troubles with preserving state correctly and transferring it, and this is a problem that is very hard to solve as an object oriented system but very easy to solve as a 2 communicating processes. In terms of sending. Symbols to one to each other. But there's a two pipes. The think about this on on your spare time, you can ask questions in in the chat if you want. So there are other problems with object orientation. Picked it here. Yes, the conclusion panel is Michelle is one of the process. One of the problems. That it's hard to express it naturally. And one of the solutions to what is was, have you ever heard guys, the term actor? Systems or actor based programs. To concentrate in object orientation led to the actor based systems. Which? Are now used in many massively parallel systems, for example. Have you heard of Microsoft Orleans? I don't know whether you guys heard. Which is fueling Xbox. User interaction. On the back end and the system which similar does it for PS4 or PS5? I don't know which one is the latest one. It is completely written in Afterbast system, which is current object. But anyway. Object orientation going back I guess. Peter, do you agree that? This is good, but this is just another tool, so we need to it will not replace proper decomposition, but it can help in a tactical design. Problems with like in Java for example, there is a common notion that everything should be an object, like a class, right? And that. Yeah. And that usually leads to design problems, sometimes functionalities. Is good enough to just create a function and call it. And not create like a bunch of classes that have no real meaning and just duplicate the. Interfaces, functionality and so on. Just more expensive. OK, now, Peter, I think we got to your favorite part. The solution? Yes, solution. So what do we do? What do we do is called volatility based decomposition? So this is the good way of finding and refining the concepts that are hiding inside the unrevealed architecture of the system. And the I think there are two ways to look at that. Maybe one of them is volatility. The other one is risk, right? Both of them more or less are related to change. So the idea of the architecture is that we want the components to contain changes. If there is a change coming to the system, we want it to affect a single component and not have any effects on other components. From the example of the house, the power system is a good. Candidate for a component right there is high volatility. In basically everything about power right there can be different sources of power, like you can get that from. A solar panel or something else? The the the cords can be different. And yet every appliance in your house uses the same interface. And so any change on the way the electricity is produced does not affect. Your. Charging device for example, right? So this is a good example of of the. Good concept. Same to get right. I think that we have a slide for it too, right? And a bit later. For example for. Capturing any object that can be stored in the version control system, we use something very abstract as a BLOB so that any change to. The nature of what we store does not affect the other parts of the system. Yes. And on the 4th bullet. You. Added seminal work of David Paris, which has. Which is called on the criteria. Used I don't remember what was. I think this is the title right? On the criteria, on the criteria to be used, the decomposing This is the name. Yeah, this is the title. systems into models, this is a stamina paper from David Parnas. Between 1972, I guess. Before this is very simple idea and it's on the surface it's not something. Ordinary we were. We got into this system of programming without knowing this to our big shame, and we called it friction based design. Because we were finding the parts that has friction, which is volatility in these terms or change and that's where we're focusing our efforts and I suggest. You guys go read. This five page very simple. Article to grasp the idea of this change based design or volatile the best design. This is where I guess Peter has some very good insights. Exactly. So the important bit now is how do you identify and use the volatility to? Produce an architecture so volatility is not self-evident, right? The customers that ask you to build a system would not will not come to you and tell you that this part of the system will change and this part of the system will not change this part of the system will only change. Twice a year, and so on. So only by examining the. Requirements and packing them, for example through the functional decomposition and looking at them and asking the right questions about requirements, can we find the areas of volatility? So. There is a significant difference between change and volatility. Not everything that can change is volatile, right? So. Change usually just produce some conditional logic so you can have some. Like to have an example from Git so you can have different languages, for example right? But. The the majority of them is known and you can conditionally apply some translation logic that would. Produce you a solid design. File types on the other hand, is volatile. You do not know which formats are to come, so this is an area that requires encapsulation. Now, how do you find volatility? So volatility usually happens at certain access. Like here is some simple examples. That are related directly to requirements. And the the there is an example of two orthogonal access. So one of them is that you may have. Multiple customers think of a customer as in very broad terms, right? So it can be for example if you have an application, you can have a front end for it. That's a customer for your back end module. So in order to identify volatile parts, ask questions like can I reuse this module for a different customer? So you have an idea of the design and try to think of can I just take that and apply to a different domain? Here for your house example, you would identify that volatile between different. People that live in different places. There are things like structure, neighbors, neighbors, the city. Those are volatile things. Those are not volatile. When you look at a single customer over time, right? The customer usually leaves long enough in a certain city. The neighbors are mostly constant and so on. What is volatile is that the furniture can change. The occupants can can rearrange. You change the appliances and so on so forth. So when you define the components based on the volatile areas. They are not actually producing the desired behavior usually. Sometimes they do, but it's not the rule. The required behavior if you look at even at the Git example that we had. The BLOB itself does not achieve any. Functionality. So the behavior that. The is in the requirement is accomplished by some kind of interaction between some encapsulated areas of volatility. It might be several components. It might be one, but usually it's not the component itself that produces the required behavior. I swear. Yeah. Question to you to the audience. This is a good question. You guys already looked at the git, right? So what are the volatility areas for Git? Mentioned to Beast one right. So for example, the files maybe 2. Two at first. Is file a volatility area? Can we say that? The branches. Are something volatile so that in a project we have a lot of feature branches and they can charge rapidly, so this also can be something volatile. Or tracking, et cetera. Huh. Try to identify the axis at which this is a volatility. I don't understand your question, Peter. So go ahead. Yeah, go ahead. No, no, go ahead. All right. So. Go back and think about the requirements. Requirements will give you access. What are the your system has access all the change right? The users you have files, what else do you have? So basically the question is what is exactly volatile about branches? Countries, yes. So let let's go to sorry last week. So the branch itself. Do you understand what the volatility means? I think which can be changed. That's true. But not for yes. But again. Yeah. Don't change so often. Not even just often. Also. Unexpectedly, I would say. Expected to. So the changes not equal to volatility, right? So if if the change is known, you just write an if else statement right and the change is contained within the module. That's it. Don't need to, you need. You don't need an obstruction for. What what would be a good example? So this is an example the UTF. What is voltage though guys? You have a tractor, right? Sorry. I talked about the GCC example and there was converting the UTF into 1001. So what is the volatility? The yellow parser which need to parse the source code right? What was the voltage? So here is the explicitly says volatility requires encapsulation. So what was the volatile in the? The change that happened to. PCC that the design of. This. A couple of the bloating functionality that you are doing in the components was bad. Well, it's too complex. What is UTF? What is Unicode character? Because, no, maybe you don't know if you don't know what. So you say. Don't know. What's the most important thing about UTF? Encoded right. The volatility comes from encoding. So the place where you need encapsulation is that. Encoding. Equality charge set so you are changing when you are doing only ASCII. You don't need to think about Char set. It's one charge set ASCII, but now you have different encoding, which means you have different char set, which means that even the question of belonging charter to something is this Charter an A it's not self-evident. That requires encapsulation. But now Charter is not simple char. If you're encapsulate that, it's a good way to do that. It's a good way to kind of address the volatility. Here is this clear. Huh. OK. I flushed it anyway. Peter, I think you identified. Yes, I was gonna. Sorry, I didn't understand the connection between UTF. For example language and script and volatility. So how it makes the changes unexpected? Oh, right. 'Cause nobody was expecting that. ASCII will go away and the whole system was built a parser. Let's take a good example. Parser was build. You can compare sign of an equal. Is this if it's equal equal equal, it's the operator of equality, right? But now everything changed. Mm hmm. You can't compare. What does it mean equal? Equal because according changed. So now you have different encoding, different comparison, different semantic and even different meaning of the equal equal. These are changes which were unexpected and they they are comprising of volatility which needs to be encapsulated in the into the notion of try, set or chart. If you do that now, the logic of your parsing will not change because if your anchor sweated correctly then you can. Still say, hey, maybe you instead of doing is equal equal. Cha cha. You can say you can call a function is equal. Move on. And I understand. And for GCC, can we say that? The CPU architecture can be. Volatility for GCC because. We adopt GCC to support CPU architecture, right? And we if we change it so. That's a good question. And think about this. I'm not going to answer it now. Very intentionally, but. When where the CPU architecture kicks in in the compiler? The last level of compiling. OK then. Almost answer the question. Say, please think about this. We I want us to go to the problem K to get in from the problem K and we have maybe 3-4 slides to go. So let's finish it. And if we didn't manage, please write in the chat. OK, OK. I will also OK. OK. Thank you. Yeah, Peter, you wanna put that? Yes. I should hurry up. OK so. You wanna cover this quickly? Sure, it's this is just. Some random list of volatility volatility areas that I identify but not complete. Or maybe something is missing? But this is what would you you would do first as a first step in. Attempting to create an architecture. So first I'll like create a list of volatility areas. That's the most important part. And then if you go to the next slide, I have like a very. Short example of how. To map those volatility areas onto components, so volatility areas would not map to components 1 to one. So there is creative effort to it, right? So you don't. You do not just. See the BLOB concept within your requirements that are then. You identified that files are like file types. Rather is volatile. Then you create a concept which is for example a BLOB that the the going from the. From the volatility area to the actual concept is some creative effort. So this is what we this is the effort we spent when we are designing the system. So I think I said that already, right? So single components usually don't encom slate an an area, so there are. Differences to that and the closing slide about again. To underline that changes are not utility, so there are changes that can for example, happen rarely. And house example. You're you're moving to another city. You do not have to encapsulate for that building. Like for example if you are building a system for a single laptop to track your. Day activities. If you are to. Encapsulate the the volatility area that you identify as, for example. I want this in future. This might become an application that is running. Distributedly across thousands and thousands of servers. Your design will end up. Looking completely differently from the original one, and it usually does not make sense because you are solving a different problem. This is very much related to speculative design. So over doing the volatility. Area discovery. Is also not good. And if you identify everything as volatility, we end up with much more complex of a design and you hence increase the complexity, which is what we are trying to avoid in the first place. Yes, here are the examples for looking at Peter nailed it in terms of. How to find volatility and how we should start thinking of it and 'cause this is hard. Nobody says that we will get it from the first time and we didn't get it from the first time, so it required lots of trials and errors and enormous amount of practice to do this right. And at the end of day, you are coming to this. So this. Is example from the dual Loe book. The training system like. We are all of time. Going to spend time on this, but I want us to discuss this in the chat. Maybe next time. I'm I'm sure we're going to talk about this a lot more because we cannot do this the first time. And here is an example of the same system based on the volatility. So please take a look to this. On the blend on this. Think about this and let's go back to our problem here. First of all, nobody ever even submitted solution to the problem, OK? Was it hard? What was happening? Anybody working on a problem K? What I have submitted for work, but I guess I haven't submitted in the chat. So where did you submit it? I just sent. Mail I have. Oh no, I just send it on your discord. Oh, I haven't seen, OK. Thank you, rajnik. I will take a look because I haven't seen it yesterday. Maybe you did today, OK. Yes, I need to. The prod the idea of the problem K was not to get the first solution, but it was iterative design. So you guys did the first iteration, it just wasn't there. I don't know anyone else. Did anything on problem K? No wonder. So now we're doing the next thing. And here's the example of a candidate candidate's desire. This is a real example. This is one of the submissions for. The homework. This is what? This is his design and now. You guys. Bring the knowledge about the volatility based design and the OR friction based design. All you can assess, first of all, you need to assess your own solution. But I knew that. Maybe one or two will do the homework and the rest will not do. Goal assess this design. And based on the assessment, redo the. Homework or create a new design. And submit the solution. Good. Rosnick based on your knowledge. Was your similar to this one or not? In some parts, yes. In some parts, no. But actually it's similar to this. No. So good. You see any? Just I had to. Sorry, just I had. Parser. And this parser was. I was I. It was just this part term pattern but. I guess that part when cell is going to expression and value. Before that I had parser cell went to parser and then parser was just evaluating expression and value. I guess that's the difference, but but the parsing part is not working because I had some issues there, but I guess. It will be solved. OK. So. Now we have one more week. All of you guys, we are definitely Sorry, I have a question. go ahead. Should our cell will be connected to our value or the opposite? That's a decision you need to make. I'll give you an example. I'm not I I put it here solution. This is one of the solutions. This is not. For example. Right or wrong solution? So I put question is this a good or bad solution? Oh, OK. How do you assess it? What type of decomposition is used and what type of changes based on the knowledge of the information? Knowledge from this lecture you would do this design or your design. 'Cause, we are learning not only to. See something and then repeat it. We are learning to reason about things, reason about architecture and reason about decision making. Make informed, knowledgeable decisions. So that's what this whole work and problem cares about. Yeah. One more week, guys. Be active on the chat. I would also suggest talk to each other. Don't you don't need to do this in isolation. Discuss this. Discuss with me. Discuss with each other. I don't know. Discuss with your colleagues. But as an Ant, not **** and no result, we want to see. Clear. Design as you see it with the rationale. Why did you do this? Or bad. But how do you decompose system? How did you identify the royalty of classes? What? How do you encapsulate the change? OK. OK, OK. Yeah, we're all the time. I think it was good discussion. Do you guys get one second stop sharing? Stop recording.