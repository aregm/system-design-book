 Type of conversations we did last time with. Me. Between me and Peter, and let me try to. Shared a lecture again. Huh. Yeah. So let's. OK. Can you see the? Screen. It's good to me. OK, so lecture 4. Last time we talked about the compositional system decomposition techniques and philosophy. How to do it? Today we are going into the obstruction realm and starting to discuss. How we are going to create obstructions and what are the techniques for creating deep modules? Do remember right, the notion of deep modules. Talked last time. Yes. Say it again. Yes. OK so. The agenda for today is going into the obstruction. Some examples of definition and definitions to develop the intuition. Right. Intuition behind it and then talk about the general purpose, the modularity. What does it mean to be a module? And here we will go. Hand over to Peter and we will discuss it much, much more detail, but before going into the deep modules and module obstruction. Let's talk about what is the obstruction in general. Well, how do you guys define obstruction? Do you have an intuition behind it? You don't need to be precise, but what is your definition of an obstruction? And they are thinking, Peter, how would you? Yes, go ahead. Go ahead, Eric. Play. For example, like an epsil class. Is a class which. Which doesn't have specific method and so on and it's just let's say it's just. A canvas I don't know, and we create the methods after when we need it. How we need it? OK. That's one way of defining it. I think that everyone who has a math background or physics background have. At least some notion of obstruction in their mind. And like we and Peter have different backgrounds in terms of Peter is a physicist, right? And a computer scientist. So, Peter, what was your first encounter with a notion of obstruction and? How did you define it in university? Oh, physics, of course. The abstractions are useful just to think about problems. So. When you strip everything from an object that is not important for the problem, you end up with some set of qualities that you unify in some. But I would call an obstruction. I think the easiest example that comes to mind for me is like. Point with a mass. So. Uh huh. They are very good obstruction, yes. Yeah, that's a very simple extraction. And you immediately see the like. When can you apply the obstruction? When the obstruction doesn't work because you can like, think of the earth as a point with an *** sometimes. Sometimes you cannot. Mm hmm. And that brings, I think, the intuition that is needed. I can tell mine was about the convergence and set theory and there was an example with the hotel with infinite amount of numbers, infinite number of rooms. I don't know whether you guys know this. In case it was a bust. Problem. Was a what? A bust. No, no, it was a hotel. So the obstruction was how I kind of like popped in my mind like it was a Hammond. Then that you have a hotel which has infinite amount of rooms and there's a conference which is going on with and all rooms are. Occupied. And then coincidentally, someone made a mistake and another. Conference is scheduled an infinite amount of guests arrived. Your what? The hotel manager needs to do to accommodate all the guests. Looks like an impossible question, right? Oh, Susie. Yeah, it's easy. You just move the number one to number 2, #2 to #4 and etcetera #4 to #8 or #6 doesn't matter. So you just move them to the next one after next room and voila, you have infinite amount of rooms available. And that was for me in the first year, and university was a ha moment about obstructions. And then, of course, we learned. That again slices. I don't know whether you guys learned that in your math course, but. That was a math abstraction notion that I've got. So then of course. Lots of other things and and then of course. Programming, object design, et cetera, et cetera. But obstructions in general are defined that you are focusing on a useful parts of the object. Ignoring the others for the matter of the concrete or specific problem. In terms of the physics, as Peter said, they if you are. Padding, gravitation or forces. Then they are useful obstruction. Is that you are. Squeezing or shrinking the body to the point where the mass in that point in terms of set theory, you are looking into. To the line. With where every point on the coordinate. What this coordinate line is just a number. So those are types of obstructions we have learned in the school, but in programming the useful definition of obstruction is that. Characteristics that are essential for the current problem and and ignoring the other characteristics of the object of this model. So let's talk about abstraction. Let's this is a real example for some real Twitch stream, and a guy was. Some space space things, space shooter. So you have a game and there are three types of characters. There's the main character. There's a ship. There is an enemy characters and there are obstacles and you need to track your objects and then you need to render them correctly. Etcetera so. This is the. AME object that the class that you have. Then based on that you are saying, OK, if there's a game object, let's write some. Classes that are representing the. Objects in our game, the enemy of player obstacle. Each of them has some type. Of weapon it can be rendered, it has direction, etc. And then you say oh, OK. So I have a duplication of code. So what I can do is I can extract the. Come on part into the thing which is called gameobject. Generalize it, and then what I can do is I can use object orientation and derive every object in my game from this generic game object, right? This is how you usually do, right? OK, put that. Is this how you usually do? I guess looks reasonable. I would do the same probably. Yeah. So, yes, everybody will do the same. Now this is good, but is there any problems? OK before going there? OK. R already flashed it, so let's call that. So yes, we have. Oh, that generalization is good. Quadr petition is bad. What are the problems? Then Peter was the first time you encountered that there is a problem which we call COP link. If you do this way. I know exactly where I did. I was studying Qt. The first version of Qt, Qt 1.1 and then we figured out that yes, everything should be derived from window with Q window and then if you have specific types of the specific things in that window you need even further specialization. And now you are very tightly coupled. In your canvas. What was your? Experience here. Think for me it was. I don't remember exactly what it was, but I remember the gist of the problem. I was writing some. Tool and for some kind of processing and I didn't do a good job of splitting the. Logic for reading and parsing. So I did the like the functional decomposition and then I had to change the format of the input and I realized I have to rewrite the whole tool again. But that was a bummer. Right. So. And here is another example from that video that. They have this class which is dumping the information from for from the game to the XML file and it's a class that has seven XML. Then it's you have the functions test which is capturing the game state and saving it. Everything is fine and then you say. OK. Now we want to do if I want to. Save in not only to the XML for whatever reason. For example, people think XML is very old format. Let's save it for Jason Tool. What to do there? What needs to be done there? Well, the usual stuff is. That's this question to you on weekend tomorrow. What would you do? Do you agree with the solution that is shown here? Did they get the problem right? So we have two different classes that are saving to one is for examle and one is for Jason. You need to obstruct it. No, the first one is they are just creating an enumeration, then they are creating distinguishable save mode save mode and in the save Excel. Now that's my laser tag. Here so they have the save XML they say OK. Now let's say if if the mode is XML or the mode is Jason and if the mode is XML, we are doing this this stuff if the mode is Jason, we are doing some other stuff. So it's just if then else we save mode. Is this a reasonable solution or not? Might be, but I can't tinkle. Can't think of other solution. OK. Yeah. Then you end up with saying oh, OK. Now I have. Save Jason class and Swallow save XML class. And some format to say, OK let's remove the XML and keep the only Jason. And to do that correctly, you say OK. Let's do whatever you said. Right. Whatever you want your intuition, let's create this. Up. Plus, which will abstract a call file saver, right? And then have two classes derived from it. So Jason. That is going. To do the specific format. Now the question is that is this a good idea? Let's say you are doing code review and you got this in your PR in the PR that you need to review, what is your reaction. Like, how should you reason about this decision? What do you think? What's your gut feeling do? Well, my first thought about this is. First of all, probably it's nice to have an interface. OK. Overall, if I want to pass that object somewhere and then call a method. That's kind of good. I don't need to specialize the code that uses those files file savers now because I have an interface. The other thought. In the opposite direction is that. The base class doesn't do anything which is not great. That means. The there isn't really any like an obstruction here. It's just like an A convenient way of accessing the functionality. Exactly. Alright. The first question you need to ask is what is the value of this abstraction layer? What it's abstracting and what value it brings to the consumer and to functions that are caught. And one of the. Usual questions that we started asking last time you remember guys like we were talking about volatility, best decomposition, what is changing? What part can change? How should we abstract it in terms of this line or site of change and one of the questions you can ask here is that what will happen if we need to save in a different string? Not file. Maybe it's input output stream? Maybe it's socket, maybe it's something else. So what? How this interface will handle that? How this obstruction will handled? And yeah, go ahead. Minute. Say it again. One minute can I see previous? I think. It will. And then if we try to. Say try to save it in another format. Not like in. Just just on our XML. Mm hmm. Because maybe I'm mistaken, but. File save class file server is something. Abstract not defined, so we can defined however we want or not. OK. So you're getting to the right point, and practically what it to say, you got almost there that if you have many implementations with complex construction and. Your even then else is long enough, then might be worth it. So for example here you need. Hey I want to switch in the. The switch is. Saving it to different modes XML Jason into file database into some storage in the cloud. It could be stream on the network etc. So in that case, yes, now you can have this switch, which will go into the fast server and instead of keeping that switch in the. Game state you will say. OK, I will just create the proper file server instructed away and then I don't care where it goes, it will be handled in the. Top class. Instructional which is the right way to do the other? Case which worth to do it is when the execution is separated from the crash in terms of for example you have a deferred execution and in this case you have this interval saver which saves every. Tell ta ta. And for that you. It's very convenient to say, OK. Now I can create, I can have this obstruction which will have. Saver State and time spawn and I don't care what time spawn is what I'm going to save. I will just put it there and the rest the proper obstructions will take care of it. And this example was to lead us into the. To develop the intuition and understand how we are going to create proper obstructions. And how we're going to attack the first, most, maybe the most important or one of the most important things that deep models we talked about this last time, right. Vital. And you put here some something really important that. The abstraction and observerted into the module is first of all representing some design decisions. And. It should be invisible to the implementation. Should be invisible from the consumption part. Can you elaborate on this a little bit? Sure, this is exactly the idea that you get when you think about the. Adult with the math. And so inside the obstruction inside the module you hide anything that is related. That is unrelated to your actual problem. Meaning that if. I take this simple example. The interface for our Earth is just the mass and its velocity. For example, right? So the factories that are built. In the oceans and the evaporation to the atmosphere is invisible. At this interface and that's the hidden information. No. So the earth might my point. Implements some mechanism like the math. Relates to other masses by some laws and this is hidden within this module that is behind the obstruction of a point with a mass and velocity. Same with the. Computer science when we want to. Build a deep module. We want the surface of the module to be as small as possible, so meaning it would show it would expose as little details as it can, so that the. Leverage for the user is still enough, but since the information is much less. It could have been the the complexity shrinks. Mm hmm. So here for example I have. A tree example, right? So you can think about maps and stuff like that, right? So at the as a user you see the interface that allows you to insert a node, right? For example, you can insert an integer in a map. What you don't see at this interface is how the memory's allocated, how the trees inside is balanced, how it handles the. Restructuring of the of the data structure with relations to its pointers and so on. So there are many things that are hidden from you and This is why this abstraction is deep right? So it does a lot of things behind. Simple interface. Yeah, exactly. And I think that there are several good examples here that will put the I really like the example of the garbbbish collector, and there's not only garbage collector. Garbage collector is the ultimate example in terms of it doesn't have interface or operating system thread scheduler right? It doesn. Have interface either. So no, it's not correct. You can. It isn't. You can, yes. This is why I put it in quotes, because that's not exactly true. Yeah, but. This is good and I think that you put here the TCP example. Very good. It's that. Protocol in some sense is a absolutely formalized abstract interface. It's not even tied to the implementation. We're saying, hey, if you want to have data transferred, you need to have these type of interface implemented in your system. Then you can transfer and I think this is a very good example of how we can detach. Interface from the implementation. Do you guys understand it? Get it? Like Arabic, Tamara is it clear for you? Yes, kind of. Yes. No. Did you get it over time? What was your? Why? Why the invitation? I was. It garbage collector. At that part, it was. It wasn't. Understandable, but we know it was. Part of garbage collector. The example for garbage collector is that you don't have to know anything to use it. So there are languages that have a garbage collector, right? So you just allocate the memory. Yeah, you allocate the memory and it disappears sometime after the after you don't use the object anymore, right? You still uh, huh? So there is no like there is nothing for you to know about the garbage collector for it to be used. And that's not exactly true. Because if you want your application to be performant then you have to know about garbage collector and you have to know about how it works. And when you do have to know about how something works, that means that it becomes a part of its interface, right? We've talked about this last time or I don't remember when. But anything you have to know about a module to use it is a part of its interface. Sarah with. Like inner classes in some languages playing Java, some Java classes that we use. Do you mean by that? Sorry. What do you mean by that? By inner classes. Like there's some Java classes that we use that it wasn't something that we designed or made, but we used them. Sometimes not. Knowing very good how it is made or something. If you don't have to know about how it works and just know the semantics, you don't have to understand the implementation. Uh huh. That's actually an indicator of a good design. OK. We can check for three minutes or I will be right back, OK? So. The. The opposite of information hiding, right? So how do you tell that information is not hitting? This is called information leakage, right? The this is the first example is exactly what I've hit myself when I was starting to write code. And when you have multiple modules that share some kind of same knowledge. So in this case this is some kind of a format. Which is split between the reader and the writer. So imagine I'm writing a program that parses a file from some format, then does some processing and then stores it back with the same format. For example. That means that if I do a functional decomposition and I have two modules that do reading and writing, then both of them have knowledge about the internal format of the thing. And that's, of course what's bad, right? So it's bad because when you have to change it then you have to. Your change is not contained within a single module and this is what we've talked about last time, right? So another case of that is temporal decomposition, which is pretty similar, and we also talked about this last time. And when you have a sequence of actions that have to be done and you just split them into modules that implement those functions, this is what we discussed thoroughly, right? So we've talked about. Parameters we talked about error handling, exceptions and so on. One thing that is also interesting and does not get too much attention is the thing we call overexposure. An example of these is default parameters. So sometimes. When you design A classif function or something like that. There is. You want to direct its behavior by some parameter. Of course, sometimes it makes sense to have some default behavior and the default behavior choice is important. The default behavior choice should be something that user expects. When you fail to provide the default behavior that the user expects, the user has to extend their knowledge. To use that parameter, which is essentially increasing the surface with which the user is interacting. Basically, you're making the user. Expand the knowledge about the interface of your thing. If they don't need to think about that then. They pragmatically the interface is smaller and the enhance your module is deeper. You can think here about like something like a vector, right? In many languages it has an allocator that is. Has a default value which you don't normally even use or even know that it it is there. With that said, information hiding only makes sense. For those. Pieces of knowledge that the user does not care about. So you can't just put everything and obstruct. All the details that are necessary within the module. If you don't put math into my earth example. Then you can't work with it. The obstruction becomes useless. Any questions here? No. I don't know, Eric, are you? Can you move the slide? If he's not, I'll just reshare. OK, she's not here. I'll. I'll reshare. OK. Let's see. Did it work for you? I don't see anything. Yes, we do. Nice. OK. OK. So where we are here? The next. Option that you have to make a module deeper is to approach the design of the module from the point of view of making it more general. So the the more general modules are the. The deeper the functionality so. Specialization usually leads to complexity because you have to set up for something that is special. And and to get there you may use a very simple trick. Just a Yeah. question. Sorry. It will quit it just just the first slide. Is it what you want to show? I'm I'm sharing something else. Let's just lecture for the first slide. Yeah, you're sharing the slides, but it's on the first page. I think we should go. Sorry. OK. Yeah, sure. Go to the. Share it. Please share it please again. Are you on the chair? OK. I can share. It doesn't matter for me. Do just one sharing OK, one share. Mm hmm. Yes, yes. OK. Now you can see it right. Great. Making modules general is usually good, so think about again as a very simple example with a vector, right? So you may store a collection of elements and a good way to do that is provide an abstract vector of things. That's just a collection of some things. With that said, some the generalization makes sense up to a certain point. I think we touched that also last time when we talked about domain decomposition. So some things cannot be. Null specific. Some things will be specific to your application to your domain, so those cannot be generalized. Or they can. But the generalization would lead to poor design. That would mean that you would. End up with something like an object. If we take the first example from today's lecture like we have the a game object and when we go further up the tree of obstructions we we made-up end up with an object then we may end up with something like. A doer of something which don't make. Any sense for your practical reasons? And they just eat up the resources. The machine not giving you any benefit neither with. Power obstruction. Neither with complexity nor with performance. Yeah, this is very good. So for example guys, what's your favorite or most commonly used programming language that you are working now? Java, Python. Jav. I'm familiar but Java, but I think that you should have there something like RA, right? Java has some runs. There's something like what? Ray vector. Yes, yes. And what is the interface for array like? Have you ever thought it like how they define the interface? What parts are mandatory? What part are non mandatory? Sure. Should be something like array of distinct type, right? Because Java is a statically typed language. And it should be some type of memory allocator if I'm not mistaken again. But I remember wrong. It might be not applicable for Java, but the whole idea of array generic array interface in this type of languages is that you have some type of memory allocator. Which will give you continuous memory location memory through it in which you can contiguously put your elements on each element is distinct type, which means that it has a very specific. Size or it's integer, it's eight. Then it's 1632 or whatever, right? We just talked about that, sorry. Uh huh. OK, you are good. See so. OK, then what was the conclusion? Sorry that I missed the part was emergency call. We looked at it from the perspective of. Default parameters. I see. OK, OK, good. Good. In any case guys, I think that one of the. Look around your day-to-day activities and start noticing these obstructions. Why stop asking yourself, not just accepting them, but just asking yourself, OK? What is the abstraction? What is abstract form? What is the last use case like? Is this interface good? Is this module deep enough? For example array. Did you talk guys about array deprec or not yet? OK. Let's maybe we are going to talk about this later, right? So let's let's move forward. Uh, sure. So to wrap this up. And when you're trying to build like more general purpose modules, you start to generalize. And then after several steps you end up with some interface and there are certain things that you can ask yourself to be sure that the thing you ended up with is git, right? Here I've put some examples of good questions to to ask. I think the most important one is the last one. So when you generalize, you should not sacrifice the ease of use. So if you've generalized that your current problem is not solvable easily with your new interface, then you kind of done a poor job. Then you've obstructed that so much that. The immediate needs are not covered. And when you generalize, you're expecting that this will. This will bring you benefits sometime in the future. But if it doesn't bring you benefit today, then you have little chances of it doing that in the future as well. Yes. And I think that one of the key points here that Peter. Is that even if it brings some benefit today, don't over generalize? It's very easy to over generalize and say, oh, I don't know, let's cover these chaos. Let's cover that case. What if? Aliens will come and try to use a rail, et cetera. Don't do that. It's very easy to fall into that trap. And it requires lots of discipline not to fall into that trap. To stay at the right. You. I'm not saying don't generalize and don't create obstructions, but you need to be disciplined to stay at the right level of abstracting. Because if you. Is the right level rack. Oh, that's that's $1,000,000 question. If we knew what the recipe like little bit of salt and little pepper and you have the right level of traction, that will be too easy. But no, it comes with experience. It comes with asking questions like the Peter was telling you that. Do I cover the immediate needs currently and going back to the last lecture about the change? I do. I clearly see the side or the vector of change that can happen so I can tweak it with of this obstruction to cover the future changes, but not. Do it over. Complicated things, and one of these over complicated things, for example. Hyphen, like everything is object. It's wonderful that I think it's Java. Everything is objective, right? Everything is objects, so practically you have this huge tree of objects that you can interchangeably use. The in reality you are mostly using highly specialized versions of these objects. For example, I don't think you are dealing with integers as an object. Usually you are dealing with them as an integer. To effectively and efficiently represent integers, you need to specialized object. The same is true. I think the same is true with Java, and the same is true. I think we're sorry. It's true for Python. I think it's true for Java. And it's true for even C++. In C++ you have. This very specific. Language construct which calls pamphlet specialization where you can create abstract interface and then you can say, but you know what? For the case of this. Parameters or for details of that. This is a different implementation of the class. And that's nice to have. So let's go and explore more about what's the right level of deepness we should do. And Peter, can you go to next slide? Yeah, we'll start. We start tackling this right, correct? Exactly, yes. So here I have two examples of. Dealing with the. Level of specialization so. That's a hard word to pronounce. Specialization has to exist somewhere. So. The approach is twofold. You either push it upwards or downwards downwards. Here are the two most probably prominent examples of doing so. For the first one, you are moving the complexity and put it onto the user of the module. Here I have the example of passes of optimization passes inside the compiler. In this case I picked LVM. Lvm allows you to create optimization passes that just go take in the intermediate representation. Of the program and process it and produce the same intermediate representation. So they just transform it somehow. This is why you can chain them together and any compiler that uses LLVM infrastructure just takes some set of these passes and arranges them in the way that is specific to the needs of that compiler. So thus. This is important to kind of pause here to did you guys get it? So did you understand? Reph rephrase it first so. Yes, please. How's the day? So the logic that lays inside. These passes each pass represents some optimization. The logic is generic, so there is nothing specific to any particular platform. For example so. A compiler that is compiling code for from C++ to X86 will have the same code within this pass as a compiler that compiles FORTRAN and compiles it to arm, for example. So the. The. Specifics of what happens with this generic code is now a responsibility of the user of this module. So the user on the on the right. I'll also take my laser pointer. They they arrange the passes in the way that they need them to be. Let's give it an example. A work specific example. So compiler gets the source code represented in a intermediate form internally and then it goes start optimizing. Each optimization is called pass. Each optimization does something very specific. For example, I don't know Whoopi, William. William called motion. You'll find that, hey, this there is a variable that is. Predominantly calculated inside blue, but it has nothing to do with the loop. So you can move that calculation of the variable outside of the loop. That's done by a transformation. The compiler is called which is called pass. So there are many many such transformations which are called optimizations and to get specific compiler you need to chain these passes, right? Which exactly? Which types optimizations you want to have in your compiler? It's up to user so now you can. In some compilers you can have this specific optimizations with motion. So that is you might decide to augment it in the because compilation time is more important for you. Sorry, did you guys get it? Kind. OK, tomorrow. Of. Linda. Say it again. Kind of OK so. Ask questions. Yeah. So do you guys understand this? So there are two strategies right to tackle this personation. Either you push it upward and this is the upward means that you give them options and you say the specializations comes from how you combine them. Or you push it downwards, which is the next option. Yeah, the opposite of that would be to have the code that arranges things generic, but the the bottom most parts that are specific to the whatever need that you have. Here I have an example of a unified memory framework, but you can find it in any sort of system that use something like a plug in architecture. So there is some code that that works with plugins. That have the same interface, right? So in this particular case, for example, I have an interface for memory pool, but the pools can be different, right? A pool of memory is just like a bunch of allocations that you can just query to get some memory from. And here the specialization happens inside the pool. So the specialization implements the API, which is the same for any such module. And because do you understand this? This is like think about it as a malloc. Why are we doing the language like Java new when you call new? Right. What is happening? New is a good example actually. Whatever deep module, right? So with the specialization pushed downwards. Down. Further into the deep new What does new do? Goes and uses some type of the module which deals with the memory allocation. To allocate memory. Now memory allocation is a very complex task. It's not simple, and we deliberately chose here real life problems and not like artificial problems to show you the how it is done in the real the production call. Goes choose the module which deals with the memory allocation and the with memory allocation. Go log to the Linux code for a malloc or Java is also open source, right? If I'm not mistaken, this you can go to look what NU does. So it it needs to understand why is my memory and I'm oversimplifying it very, very much. Where is my memory? Who is dealing with my memory? How much memory I need to be allocated? Can I have that memory allocated? In which type of memory I need to allocate? Now imagine you have multiprocessor CPU. Is this can I? Do I need to allocate closer to this CPU or that CPU OK? Should I allocate it in the CPU, GPU, FPGA, et cetera? So there are many, many, many decisions needs to be made. That to get just one location and one of the examples that one of the frameworks is doing with it is called the unified memory framework. Which is abstracting all that question from you and giving you a very concise and simple interface like malloc. OK. Between usually. Let's say allocate some part of memory we are not aware of that. Things like we don't make any decisions. You don't make any decisions, right? Usually compiler. But for example, that's what I'm saying that the the new is a good example of a deep module, right? It's it deals with. A zillion amount of things to give you just one location. Is it clear? So if it is a upward specialization. News download specialization 'cause that's the example of the Yes, yes. downward specialization. The upward is. The we chose example of the LLVM saying that. Huh. Compiler can do very very complex things right? Very complex things. And to do that, those complex things you need internally to do something. Now there was some things are represented as a. It's called pass. It's called optimization pass. Now you say, hey, I want my compiler to do the best soft. Speed. The best performance get me the best performance out of this code as much as it can. It means that you need to combine set of things. In this case, passes to get the best performance, so you are explicitly giving a user an option to say oh, if you want a fastest code, you need 83 passes. And buy them together. Round them you will get. It clear or not? Turn this kiss user makes choice. Himself. You said it's the interface is still what is called task manager, right? But depending on what do you want you deal with it differently. You does Java have optimization options. Yes, JVM does. Uh huh. OK. So think about this. There are those optimization options are creating different task managers which are creating different which are combining different passes together. And this is how you reach specialization. OK. Combining things together as the opposite, when you put them downwards, you're like creating different, for example plugins for some unified interface. OK. It or not? Yes, I did. OK, thank you. Tomorrow, is it clear? Or more clear. Guys don't hesitate to to ask questions. OK, let's move on. I think we can skip this, yeah. Special case. Yeah, sure. This is important, yes. Instructions, yeah. So software is usually built in obstruction layers. We had this example for unified memory framework and you may have noticed that there are like layers that provide different functionality at the top level you just get something like a new and that's it. If you go down, you can have like a different layer of abstraction where you can handle a pool. You can configure it, you can set a different pool and so on. And at the bottom level, you may choose to like use a different memory provider, whether it's like. The the operating system or it's like a device memory for some accelerator and so on. We layer it. Architecture allows you to separate the things that. Are maybe changed within each layer and so they contain the change. This is exactly what we've talked about, volatility. Based. Abstraction so. In this setting, you may easily notice some problematic things. Especially when you look at some changes to the current code base. Here I've written three things that are very common. The first one is pass through method. A pass through method is a method that just does nothing but just takes. Some. Some thing and calls a function of a different layer with this exactly thing. So essentially does nothing. The problem with that is that this particular piece of functionality is not deep, right? So the interface is exactly the same as the interface of what it is calling and hence you are just adding complexity to the system without providing any benefit. Same goes to pass through variables. This is usually happens when you design classes and you want to take the variable and use it in a another class which is somehow used within the functionality of the first class. And this happens a lot when we use wrappers or decorators. I don't know if they're. I don't think they does. Java have decorators. I forgot they have interfaces I wrote in Java. Interface. Now I think I don't. Yeah, I don't have the correctness right, but I don't know. Yeah, I last time I used Java, it was Java eight I think or 10. They did. A while ago. They were used. No, they don't. They have annotation. Mm hmm. Well, that's basically the same thing. This is omelet ocean. On the right here I have like an example of. What happens within a layer of obstruction? For our favorite example of Tell system? So each layer deals with different problems and works with different obstructions. So the topmost layer deals with user and user uses files. Or file descriptors. And so this is the only thing that they need to care about. Lower level the virtual file system works with objects such as inode DN Tree which is a folder and others. So these are hidden from the user space layer layer, but these are the things that this layer is working with. So if you had a pass through method for example between the two you would see something like. A method within virtual file System API that takes a file descriptor, for example, and passes it through to the file system. This does not happen in in Linux, so they convert it to an actual inode, for example. And so on. So the example speaks for itself. There should be a question. You know, do 'cause now. I was the I node. Do you know what? Have you guys? Oh. You start the operating system or did you have any classes Hello. about operating systems? Yes, we did. But we, but I don't know. I not. So have you started file systems there and how file files file systems are implemented? Tamara, I think he is right. I think so too. OK. So in any case, there is a I'm putting into the chat. Well, I. The notion which is called inode. Open locate. And you need to find out what the inode is. Sure. OK. Just an example of how it is implemented in in, but any in any way, let's continue. I think they were hitting. This is the most important central theme of today's lecture, actually. Layers, abstractions, deep models, and you cannot have deep models without structural layers, right? And. This is we're going to now discuss how. What's the next slide? I think it's it's on next slide, yes. So. We are going to push the complexity downwards. Present on Google Building a good module is extremely complex task. Yes, it's very hard building good library that has multiple users is very hard. There are very, very few libraries that has long life right. So one of the libraries that I know that has a very long life is open as a. So maybe it's an example of. The library, that is what, 30-40 years old, right? That it still has very stable interfaces. And one of the key elements of designing such libraries as modules is to understand. How you are designing the interface? The interface should be simple enough and how you design the obstructional layers inside your module. This is a very this is maybe the most. Of the second most important task. So I think that the first, most important system decomposition. What Peter was. I don't know whether you agree with me or not, but I think there are two central problems that if you study and teach correctly, most likely you will have a good program on that. How do you do proper system decomposition and how do you do proper system composition? Create obstructions. If you do those two things correctly. I think you're good. What do you think? And agree more. Yes, so. When you say here are the complexities closely related to the existing functionality, do you mean? Creating a new obstruction layer or you mean? Reframing the existing functionality in the same structure. It's more about creating the layer, yeah. I think that you guys understood the new example right, right. So you have the idea of the new example. Now I think that. Dial open or new. It's extremely deep module, right? So what is happening when you are doing new or what is happening when you are doing? Think about the complexity of things that are going there, right. If you start from the very low level memory. Boss memory management you need and interaction with the boss or on the other side. If it's SSD blocks or sectors on the hard disk. That's a very low level obstruction, right? You agree with me or not? Yes. Now you need to somehow deal with that level of granular. What do you do? You create the first obstructional layer. Why? So you say? Hey, now I think I can deal with just a local thing. Blocks with a fixed size sectors and then I can move them around. I can mark them busy. I can mark them free and that's the first level of things that I can do. And then you go and say, OK, what's the next level of things? Can I create? A chain of sectors or chain of blocks that represents some type of logical entity and I don't know what logical answers is still still is, but it's it. Should I should be able to deal with not only one single block but with block of blocks or list of blocks and then you create the next level structures OK. Now I need to do. Blocking should this block? Now you have the decision to make. Should these blocks be contiguous? What will happen if? A block is marked free. Cannot allocate into different chain, et cetera, et cetera. Then you say OK. Now I have channel blocks. Now I can have more things to add. What if I want to add encoding? What if I want to add Indians? And then? You can. I haven't named block. I have named block. Now what? How I'm going to store this name block? What is the difference between one name and the other? And that's the next level abstraction. And you go up, up, up. At some point you will say, OK now. I have. Open my chest file path. Permissions. And. Mode, right? So that's only three parameters to the. To get there, you actually did lots of work. You created multiple levels of abstractions to get. There. What? You understand this? Yes. OK. Design process is usually go ahead. It's possible that. OK. I know nothing. Sorry, say it again. No, I I said nothing. OK. And that process is usually the the opposite in terms of the you first say, OK. I have this interface and I would like to implement it. But the key point here is that the notion of that interface somehow. Needs to be connected or needs to be mapped correctly through these obstructional layers to your implementation. It's a very hard problem. Think about like TCP or any networking protocol, right? You have layers of abstraction in the Wi-Fi model to start with. The physical link logical. Transportation application, like every layer, has something to add on top of the others. But because you know what you want to do in the top, you can structure those layers correctly. But Peter, you have here an example of something much more simpler. Oh yes, that's just an example of. Demonstrating the problems with the. Putting the complexity upwards so. And actually it's usually somehow better to hide the. Complexity. So sync it downwards than to provide more functionality to the user. And this is because I I think. This is this should be stressed, right? So the the first statement, so most like classes or functions or whatever. That you develop have more users than developers and what that means is it's far more important how the module is used than how easy or comfortable it is to implement it or change it. And so the example here is just to demonstrate the problem. When you want for example, you have a method that. Let's let's talk about parsing again, right? Because it's a simple example. And it allows you to parse with different different file formats in different modes. And there is a temptation to just create like a configuration. That allows you to pick and choose everything about it and just pass this like a class to the user and then just ask for it in the interface for this parser. The problem is that you're delegating the decision to the user, right? So instead of just looking at the file and figuring out what type it has and what mode should it be opened with, you are increasing the complexity at the user code. Instead of hiding the complexity inside and that makes your module shallower. So the the other question that usually comes up is whether or not to implement things together or apart. So usually. Oh, we've discussed this many times. And your goal, of course, is to improve modularity and reduce complexity. And sometimes these these can. Be an obstacle to each other. So if I'm taking these two, two extremes, I'm either ending up with. One module that implements the whole thing, kind of reducing the number of components too many components is bad, obviously. So let's reduce them. We end up with a single component. Single component is of course too complex because it has. It has little modularity. Let's improve the improve it and make more components. And then you end up with a large small components. So I illustrated with this 2 graphs. So, first, modularity is usually beneficial, right? So modules small modules are easier to understand. Maybe not small, just modules that do this this single thing. You can compose them. You can reuse them, but it comes with a price, right? So. Modularizing can use incorrect heuristics, so like like code length to make decisions about how do we create modules. And that adds to complexity. When you have more modules, you of course have to manage them. You have to learn the interfaces and you may have non obvious dependencies between the modules and the dependencies. Will will always be there of course because your code needs to be stitched together somehow. On the other side, you can bring the components together right to deal with the problem of too many. Components. And this makes a lot of sense when there are two components that share information, it's usually better to create just a single module that implements the whole thing. You can simplify the interface if you get more functionality into the module. You can hide some details because this is all done with in a single module. And you may end up with less duplication. And of course, this leads may lead to less clean obstructions and may lead to bloating either the implementation or even interfaces. This is just a small illustration I've taken from the book. That shows how the. How splitting the implementation should or should not be done so? I think that's a question and I here I have like a four options, so one with a single interface and implementation. This one has like a separate block with a separate interface that implements. Some portion of this whole module. This is like two parallel implementations, and this is a bunch of shallow modules which are is obviously not very good. So I would say probably on the. On the left, these are the two most. Good outlooks of the implementation. You can argue which one is better. And Eric, what would you argue? The best option here. Oh, depends on, I don't know. Smaller surface of interface for me is always better. I don't which one is the smallest here. It's based on the width of the module. Yeah, I think so. OK. Yeah. Yeah, I would prefer smaller interface because it's it's easier to comprehend and then it's easier to turn and I'm kind of the Unix philosophy guy, that it's better for me to change things, simple things together than have one large interface. Mm hmm. Exceptions. Except we are running all the time I would. Yeah. Maybe we should go to the homework and I have question to the. The whole class in this case represented by ARV Vikrant. Tomorrow that none of you submitted homework. For scratch it. WhatsApp. What happened? What's what's the problem? Very little time and I couldn't manage into the deadline, but if it's fine to submit it after the deadline. So it was too complex for submission. So none of you managed to do it in a week. That's what we're saying. Because our schedule. Say it again, I'll interrupt you. Complex schedule with our classes. OK. OK. Yeah. If you're still interested in solving that, let's extend the deadline. We do concur with tomorrow. Sorry. Do you agree with tomorrow? Is this? Do you have the same case like two complex schedule or you you couldn't manage the things? Oh, yes, yes firstly. So for the next time, in addition to the finishing spreadsheet. Find the implementation of F4F. Four point is a file system F4. In particular, is a very good example of a deep module. Her. Don't forget that the whole Linux file system has only 5 functions open, close, read, write sick. That's it. But inside it it has. I don't know. Maybe 5-6, maybe more layers of obstruction. So. Look into this. Start comprehending the complexity. We can measure close lines of code. We can measure cohesion or other type of complexity whatever you want and. Try to decompose it into the. Obstruction letters. And submit to your findings in the form of paper for next time. OK. OK, my e-mail file. Can I submit my e-mail 'cause I think I submitted the first time work by e-mail but yeah. E-mail is fine. I mean the I will. OK. I will create a table with your submissions to track everyone. I'm using just paper, but I will create a spreadsheet, POS it into the discourse. Everybody can see where they stand. So far not good. Most of you guys submitted the 1st paper. None of you submitted the scratch it yet. Let's see what will happen with the open. It should never ask me. I think he wrote the second homework. Why is it? I haven't seen it in discord. Isn't he submitted because he told he wrote it? OK, I'll send you a discord. A question that I haven't seen in e-mail. Is it the e-mail? Nope, no. Nothing in the e-mail so. Where did he send? Ask him. I'll ask him to discard, like if he sent somewhere he is to resend it. Because I didn't get it. OK. Can you ask me the questions? Then oh, I have to stop the recording.