 Designing systems. Putting together the. Knowledge that we already learned into practice and this is the kind of the first practice that we are. Experiencing and what do you guys remember from the previous lectures? There was a gap, right? Big one. So what do you remember? What was essential for you? What was unessential for you? We're covering Git and we were talking about the difference between design and the architecture. OK. Levon and he not from you. I also only remember to get, like Tamara said, actually participated only until lectures. I think actually Mm hmm. didn't manage to join with all of them before. Yeah, it will be good for you to go back and watch the rest of the lectures and also. Read some materials. But for today, we are putting together. The experience and the knowledge that we learned for this the past five lectures. To build a build system and the build system like. Do you guys know what the build system is? Most likely you heard about? Something and you are using something in your day-to-day work. What do you use? So could you repeat the question? Yes, what programming language are you programming content on? Java I mean. OK, Java, Java has a system which is called Maven. If I'm not wrong. Are you familiar with that system? Not really. OK. So if you have a product which is big which has multiple files. How do you make an executable out of those files? Should be one main file which executes the other ones. OK, levon. What about you? The same thing actually. OK. Maybe there's some kind of connected together? Yes, they are connected together and. The tool that translates. Source code into the executable or binary code is a compiler. The source code can use each other and in case of Java you have classes that are defined in one file and used in the other file associated in the other file. So there is a need for tool. Convert those files. Into binary form, right? Then you need to link those binaries together. Right then you need to create one executable with this linker also. To file the resulting executable can have dependencies on other components, including operating system or third party libraries. And all this is required to build. An executable from manifest and then this is a very, very simplified view of the world and build tool is the tool which automates the process of turning multiple source codes into deployable program. It can use compilers, linkers, package manager. Debugging for printers. Debugging for others. Test tools, packaging tools, etc. To create a deployable executable. And it's used to automate this task and most likely in the Java world that you are working on. Not very familiar with Java, but as far as I know. There is a tool that is maven or. Yeah, thank you, Peter. Gradle and something that is out with the automates the build process because to compile 1 file you just use Java CC and it compiles if you have multiple files then you either do it manually or you automate through the build tool and that's what. We are going to talk about today. We're going to use some examples and diagrams from the book, and I highly recommend you if you want to strengthen and deepen your knowledge in the build systems. This is maybe the most comprehensive. Review and explanation of how build systems work. Done by Peter Smith. It's quite old, but it's still very valuable and I encourage you guys to. Look into this book. So why do you need build tools? Yes, you guys. Most likely your day-to-day activities didn't encounter too much because either you work on a portion of a project or most of your projects are less than, I don't know, 878000 files and but after the complexity grows you need to have automated tools. And you need something that will automate the process of resolving dependencies, linking together, compiling, compiling and linking in that order. And deploying you are giving you one executable or deployable package that you can run. These are just the basic things that Guideo does. So what build tool can build? Various things and. And it it can automate any process which works on practically anything that has a dependency. Compilation of the source code into the executable. Then you can do a packaging and there are tools. In specific Python, based on the IPI. Package manager. There's a contact package manager. There are other package managers in CC world. We have done something like Conda. We have. VC package. What other package manager we have the package manager in C++, the Green one? Peter, what was the name? With the green logo. I remember calling for example. I'm not sure if it's a green one. That's in the C++ world, so every. Part of the programming languages. Some of the programming languages have built tools built in, for example. Goal has a build built in build tool which is part of the standard tool chain. Other languages I think Rust has something right. It's called. Uh cargo. Yep, very nice. Yes, it's very nice tool. So modern languages are kind of incorporating this tool into the standard tool chain to ease your life. Yes, and it can do other things like integration testing. You need to smoke test and integration testing automatically generate documentation, more things like running conformance suite. Spell checking, etc. So the first known build tool is considered to be a tool called Mink, which was created in the Bell labs in the early days of Unix programming, Unix operating system creation programming by fellow Stuart Feldman. And there is a very, very good book which is called the art of Unix programming by Eric Raymond. I don't know whether you guys heard about this book. I highly recommend you to read this book. I think it's so heaven somewhere here. Anyway. It's a collection of semi philosophical semi practical ideas. That inspire programmer to do a better job. So make is the first build tool. Most commonly used in Unix, Linux world and CC development, because was the first problem language. And if you encounter or if you want to build anything in the Linux world. Or even. Mark. You know, sometimes windows. You need to encounter and deal with the make. Too, and prominent well known big files. It's a little bit more complicated than it should be. OK. Thank you, Peter. The Peter put the link into the chat, so please. Bookmark it. It's. It requires discipline and. We jokingly said that it's not recommended for untrained minds. But what is it about? So Mike make is a program that automates the building and running commands on the dependency trace. Independency Tree is a fundamental idea for any build tool. So. Is based on the rules which creates dependency tree or dependency graph in this. Graph in the form of tree that runs some commands. So rules are written in text format in the Meg file which has the full the following format. You declare some target semi colon then you declare the dependency on source. Files and on the next line you. Write the recipe how to build the target from the source file. So. Target source recipe. These are fundamental three ingredients of make file. Now put that needs to be generated and it can be empty source input file or input files and the command generator. And on the right blue box you can see that we specify that LL .0 file object file depends on LLC and llh and to get llo you need to run GCC with minus C command line on LLC. OK, so make does the build pay those structural organization? How code? So far depends on each other. It is recursive if the source is also target for the other source, you then need to must evaluate dependencies first. So you need to go down to from the tree into the. Leaf level to the left leaf level and then start building up. How rules are updated? Make checks when you last edited each file. And built only those ones that are not. So recipe can be anything. It's not language specific. You can do any. You can run any shop command on the recipe line. Try make command within the same folder you do make minus F make file name or you just can run make if the default file name is make file. And it starts with the first rule. Then it builds the dependency tree and runs the recipes until you get the top level dependency satisfied. And on the. Do you know org? You can read the documentation of. Bottleneck. So what can you build? This is an example of. Very very simple. Project linked list that you have linked List H which. Defines the node. Then you have linked List C which implements the either file definitions and you have main C which does something. So now you have this dependency you on the top level. You can define try lists. Which depends on llo or the main O and to get those dependency satisfied you need to run GCC on the. Output how to get LL and mano implemented? Those targets and those files which are also targets, depends on LLC and llh and you need to run GCC on those files to get the object files and URL. Now on the leaf level. So you start building up and you get your top level. Dependency or top level target satisfied. OK, I will any questions here. Mm hmm. No questions, OK. Good then. Makefile is not that simple. I just want to. Describe that you can do lots of lots of lots of complicated things with makefiles, so you can define some variables there which will help you to reduce repetitive typing. For example you can say hey, my compiler is defined by a variable CC. The flags are defined by. A variable sea flags. Which would be there is a typo. It should be C flags. And. Then you can do checks. For example, if if Dev defines if the some type of variable is defined and do conditional execution, then you have specialized. Characters for target sources left most source right most source. Multiple recipes, etcetera. So it's practically a very, very. Complicated to be honest. Cool. It can become very complicated. The other thing which. You might encounter is called phony targets a target which doesn't create any output. So or can be used for. Action that you need but you don't want it to create an output. So most common usage is to. Clean so when you want need to. Remove all intermediate files generated during the build. Is a following target for tests or to print some messages or diagnostic messages during the build process. OK. And. Oh, this is the how we define the the clean here. Yeah, I don't why it is there anyway. This is more complicated. Example. Of dependency. OK. This is the dependency so. We have target. Talk. We have files. Shout sesh speak H, shout H and mean C. These are the object files on the second level. Depending on those C files. Then you have macfarl which has all. Make all your make all. It will create a talk. Talk is depending on mean all speak or shout all. And to get that those. Object files combined and executable generated. You need to run GCC on those object files individuals, and then you write how you are getting object files from the. Source files and you have 40 target for quit. OK. These are the variables used in there, so you can. Go even further and create targets. Create flags, create compiler, create objective files and in that case. Your make file would look like something like on the right side. Pretty simple. So target define depends on objects. For each object you run. Compiler with flags on objects. Each object is defined with the compiler and flags. OK. So this is 1st and very shallow introduction to the Makefiles and build tools. The problem that in the real world the problem. Problems start to pile up when you have logical when your project becomes. Larger and larger, the project grows. Make Falcon become very complicated. And that's where people start. Hacking around adding layers of complexity and adding layers of obstruction on top of it. And figs can, if you don't. If you're not disciplined in the build process and build tools. Things can become very, very complicated. There is this. Number or survey done. Across industry that even on small projects which include ten or less people. About 10 * 10% of the time people spend on resolving build issues, and as soon as you get. I would say that as soon as you get two people working on on a project which has more than, I don't know. 1020 thirty files. Things can become. Really complicated. Yes, and you can ask question like what are we spending that 10% on? And in real life, the industry production programming. Nothing is simple. You can have bad dependences. That your source or compiler. Has down the trees. Libraries can be missing. They will can be version mismatch between libraries required on the one side of the build dependency and on on the other side of the build dependency. So you will going to spend lots of time on fixing those issues. So OK. Any questions here? Did we get the idea of what build tools? What is important and what is its role in production programming? What? Yeah, I wanted to ask something. So you said we're using the MAKE program. Good. Yeah, for this development. Oh these I'm. I'm just doing the introduction to the Bluetooth tools using make. It's why I'm not going to use Mac. Oh, OK. Sorry, I wanted to ask. I thought maybe if like using using make it's so complicated, why don't we use the other one? Or there is no any other program instead of like. 1. Oh, there are lots of tools, you know there. There are lots of tools in for a very simple projects or even I would say that mid to mid size project make is very good if you know how to cook it. Make is standard. Make is standard in any Linux. Every Linux has Mac. So that's why it's very popular. It's the oldest tool. Do you need to use it? Not really. But understanding the origins, understanding its role in the development process, it's important. OK. OK. Thanks. Tomorrow I need. Oh good. I think another point is. Another point is that some of the tools, some of the modern build tools use make. Inside. That's true. Yes, they use make like a lower level like assembler. Yes. Mm hmm. OK. So now we're going to apply the knowledge. That we learned and build built to this is a very important. So let's imagine we need to build a build tool. This is important task, but this is a real life problem, so let's imagine. We have the plop PY which produce the result SVG. Where reproduce from. For something from collated a CSV file and that collated CSV file is produced from sample CSV file. Right. And control CSV file. By analyze py. No, nothing was process py. So we have prices and sources that goes to process PY which creates the CSV. Then we need to to plotting and then we need to produce the. Results. So what we learned in the from the make. We learned that there are three notions that are the floating around, right? We learned that there's a recipe that runs on source to get tagged. When it needs to be to run, if a target is stale with respect to any of its dependencies, and the build manager, the so build the manager. Sorry, build manager runs the recipe. To support refresh it. So build mange runs recipes in an order that respects the dependencies and only runs each recipe once it runs at all. So what is the constraint? In order for this to be possible. We need targets and dependencies to form a cyclic graph directly to cyclic graph that cannot be cycle that links from a node back to itself or room to itself. So there should not be a cycle. And. Here is the upper left upper right side. This is a cyclic graph. Abcd. Is there? Is there a cycle in this graph? No. No. OK. So in which order we should do this? To get a which in which order we should run recipes. Mm hmm. To get. Right, so a is dependent on BC and the DB is dependent on C and A. Mm hmm. DC and D are not dependent on anyone. Mm hmm. So in which order we need to get we need to run recipes to get a. A is the top right. I mean the order is written on the right, but yeah. Yeah, all the reason. The right, OK. So I see the we need to start from the Leafs, then B, then a. Mm hmm. OK. So first thing, so we need to define the concept. So we have the idea of the concept right we have. Recipe source target. So the first thing how we are going to represent that? What we can use to represent that this is just one way to represent it, right? We can one of the ways to represent it. We can use Jason format and this line where we say target depends. On the dependencies. With and to update the target you need rule, right? Is this good enough? To represent yes. OK. Yes, this is good enough, because this corresponds to recipes source target. Sorry, could you pull up the top on that slide, please? ALS. Which flat? And the other one, the previous one. This one or this one? 2020, yes. So it should be a cyclic. OK, I got it. I got it now. OK. I thought maybe there might be dependencies that we should run over in a cycle until a constraint happens. That's a good idea, yeah. Like if something happens. A file should be run, but then I understood that it isn't about this one. OK. So this is the representation of the rules. So we can use this representation. We can use simple make style representation. Think about what other representations can be used, but for our purposes this is OK we are going to use Python And we're going to use. Standard Python Jason parser for it. So the way we are going to do it is through stepwise requirement and starting from something, then gradually increasing the complexity so. Let's define a class, a concept of the build, and that build has. Function build which will get the config file. And create the order. And. I think you got this order right so. For. This to happen. We need to do topological sorting on the graph of the ball. Logical sorting is what algorithm? Guys, have you remember the descript math from? First course or first year, second year. No, sorry. Dear dear. DFS. That first search, have you heard about that? Yes. OK, so topological depth first search is the basis for topological sorting. It's the homework for you guys to see how to use the DFS to do topological sorting. But anyway, so we do topological sorting then we. Update the target and for update it's at this point we are just printing it. So first of all, we need to ensure that this is running. All the code is in the GitHub. You can better play with it. Then the first thing, yes, we need to configure. We need to load the file and loading is pretty easy. That's why we use Jason because, but but it's not. You use the standard Jason Loader for Python. And yeah. So next question is. What check does? So we load all the rules into the dictionary. And then what we need to do next? We need to check right? We need to check that first of all there are no missing roles. There are no empty rows, there are no cycles. And there's no missing dependency. So that is what the function check does. So we load into the. Dictionary and then check all the rules. Coral satisfied the requirements. Now the refresh. What is the central algorithm? How we process the graph? What do you think guys? So you remember DFS. So we got. If not taken, it goes from the route. And searches for something. Putting depth first. Right. So the first thing we should find all those targets. In the dependency graph that they don't, they don't have any alternate dependencies. So like we complete lower level of the lift S on lift S, so do you process them? Then you append the results. And remove the dependencies from the other node in the dictionary. And if there's still anything in the graph. You repeat the cycle. If any point graph is, isn't empty. And nothing is available to process. Then we have a cycle dependency. We've reported all of the print error message unfair. Here's the example how it's done for ABCD graph here. In the step files cycle. So in the first step we do D because D is available. So we add this then if D is ready and can be processed, we do BC. If BC is ready and process we do A at some point everything is in the graph is empty. So we have the order dbcl that's the order we process all the. Dependency. And. Yes, this is the cord that's on. Homework is cancelled. But think about this court doing your homework like this is doing exactly what. We saw in the previous slide this is doing the available graphs, processing them, adding to the list that the list of the sequence that needs to be processed. OK. This is now. Let's move to Dexter. So this actually will complete the. First iteration, right. So we have complete solution which. Is simple and can be. Roses. So can we do better? So what now? If you remember, we talked about the volatility. And some of the solutions. So first of all, configuration might not come directly from Jason file, right? It's the point of what? The files where the rules are coming from. It can be part of not a problem that is generating it can be. Found otherwise. Format or etcetera so. We should modify the constructor of the class to take take configuration is as an input. And printed connections to screen isn't very useful. That's obvious, right? And what we should do is we should collect them and return as an ordered list. To the to the call. If. There's no graceful way to process the errors. We should raise exception. And indicate that there's a problem. The second issue is that that's why I told you that if you look to this, you will find that there is. It's called stability of sorting. Methodological sort isn't in our topological sort isn't stable. There's no way to predict the order in which 2 equal nodes will be added to order, right? In this case, what is this case? Yeah, should we add? BC or CB? And we might want to add other keys to the to the rules. So we should put check separate method that can be overridden for the users. OK. Now we're building. We're doing a better design. So updating the function that we already have. With some internal functions, one is refresh, the second one is must. So this is just a graceful way of raising exception. So we enter the configuration. We saw the configure internal. Function. Then we do topological sort. And then we update all. The. Notes and add that to the list of the actions, and then we'll return to actions. So the configuration code looks like. Do we have to? Wait, where is OK? Input is the same. So. The configure is that we check whether the. Keys. Whether the configs. So this is the reading and checking the configuration file into the dictionary. So check does that do we have problems of missing dependencies or call dependencies and the code is the same? With a little bit addition. And the most important thing is not now we update the topological sort to be stable and. This is. Oops. The most part is what we're going to deal with. So I encourage you guys to run the code that is in a rapport yourself. To kind of contemplate all this code, especially this part where my laser pointer this this part. The crap part to understand why. Function produces the right result. Why this function will? Give the right order of dependency that needs to be updated. OK. We can talk about this next time. If you still have questions, but also we can talk in the chat if you want. But there are things that you need to do yourself to get the knowledge internalized. This is one of those things. Also, there's no production system without tests, so we are going to do testing and to do testing. What type of person should we add? Of course we should test the empty. See how. Changing of the constructor and the interface. Gives us ability to do so. Stress. So we have the builder we build. The graph which is empty and we should get empty list. Then we have one thing. One rule we have target A which depends on rule action A. We should get the action. So. The question is. It is a good design. And this is Diamond department dependence. So the thing that we discussed in the. For example, so is this a good design? We can do. And what did we encounter? Any ideas? Maybe it wasn't like the best one, because the arrows were kind of like crossing each other. Maybe there could have been a way. What does it mean crossing to China? Like. I think I'm. I'm sorry, is this like this code? Is it written for the the one in the previous slides? With the dependencies for Abcdi thought it was about it. No, no, no, this one. No, no, the other one. This one what? What problem with this? Yeah, I thought. This is just the Dell. Like, yeah, but I thought just like the arrows were crossing you. I'm I I understand that this is for the dependency, but I thought maybe it will be some other way to configure them without. How can you do that? I don't right now I just. So think about this. Said maybe that might be right. And also that's why you guys need to refresh the 1st 5 lectures and think what this is a better design. Definitely we have stable sorting. We have. We address the volatility in the input. We gracefully fail. What else we can do? There is one thing I guess, which we add here. Yes, not here. Yeah, we said that we can. Hey, added some time stamps. So one of the things that we're missing are the time stamps, right when the target was updated. So we can add sometimes done time spans, times, times, times times to address that issue also. Yeah. Also think I would like you guys to do some homework and the homework is pretty extensive, but it will teach you a lot and you will expand your knowledge here like. It is a good design. How can I use it and to use it you guys use predominantly Python or Java your work? Me personally, it's quite him. It's OK. It's gonna be. Say it again. I was just saying that it's gonna be fine for both of us, I think. Two years ago. So yeah, if you're OK with Python, use Python. Try to use it. Try to. Write code and try to use the builder and see what are the problems that you can encounter. Because a good design. Give you. Nice work rounds or seamless usage in your your project. So the only way to assess is to use it. So we addressed the updates part. And what we actually did. This is called template method template pattern. So. Where the call you define some type of control flow in the parent class. While the specialization or chart classes implement. The control flow. So we don't know how to divide our code into the methods. Instead, we are creating a class that will load it and use time stamps. To do so, also, we reorganize the parent class to create. Affordances we needed at the points of volatility and for you guys, this is the summary practically of what it looks like and where are the. Well, pot can. Well, where are the volatility? This is the structure and design and idea of the whole build tool. Of course simplified of course. For teaching purposes. But this is everything you need to know to reason about the system. OK. Nope. And homework homework. If you want to grow and to internalize this knowledge, you need to do all work. And homework is the following. Which console list the consoles that were used? Which concepts were used and what was the definition of the concept? Do you remember? Mapping of what to what? No, sorry. My thing on fire mm hmm good. No, I just think that I didn't remember, sorry. OK, mapping of function of form to function. So think about which forms conceptual forms we were using and which how we mapped it to the functions. One of the things we can do is you can use Jason schema. Are you familiar with the Jason Schema concept? No, but we can look it up. Yeah, Jason Schema is a validation of Jason input forcing it to correspond to some specific schema so we can use Jason schema in within the associated standard pattern model to validate the JS input. Jason. Now we assume that everything is syntactically correct. So modify the build managers or the configuration file can specify. Whether the rule? Should succeed or fail. But this will it's not very useful in the real life, but it will help with testing. So you can have tests that fail. The other interesting thing which is also real life that you need input from different build models, build files and then you need to combine the rules and build them together. What should change in this solution so you can process two more files or two or more files? Another thing which production system do is calculate hashes for every file and store those hashes along this file alongside with the file name. And modify the build manager to compare of the current hash files with the stored ones and to determine whether the files. Change or not? So and three other examples. And we didn't have phone in targets or how would you add phone target? To our design. So that's it for lecture part. The rest is going to be practice. So go to the. Ripple where is ripple? Oh yeah, so go to the code I've added. Fast and Peter added a bit rate dog creation so you can play with it. Yeah. And work on this OK. OK. Thank you. Let me just stop the recording.